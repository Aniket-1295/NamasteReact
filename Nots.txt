#interesting thing  about npm 
npm does not stands for node package manager (npm does not have a full form)

it manages the  installed package but it does not stand for node package manager. 
behand the scense it works as  a node package manager 
it just not node package manager but we can also hoisted our own package over it. 

basically it is a biggest repo for all the packages
we need. we can installed them in our project using npm.

--npm init
-- npm install -D parcel
-- npx Parcel index.html -- > it create server 
-- npm install react
-- npm install react-dom
-- npx parcel build index.html


npm vs npx 
npm => it install package then use 
npx => exicute a package without installing them 



#package.json

package.json is a configuare for npm.
it keeps and manage  the installed dependensies(packages) with there approx version.
and npm manages the version of all the packages  installed.

it gives the information about aour project like name version 
 we install those packages using
npm

^ vs ~ 

^ => it will works for all the minor upgrade in packages

~ => it will works for all the major upgrade in packages

package.json vs package-lock.json

package-lock.json locks the exact version of the installed dependensies. 
so it takes care of whatever is in my local version are same version present in the production.


#node-module

node module contain all the installed dependensies inside it with there dependensies also(transitive dependensies)

#Bundlers

A bundler is a tool that bundles our app, packages our app so that it can be shipped to production.

Bundlers are packages.

Examples of Bundlers:
Webpack
Vite
Parcel

#parsal

npx Parcel index.html
--generates  the Dev build of project and hoested on http://localhost:1234/



Parcel features:
-- creats local server and generates dev build.
--HMR - Hot module Replacement (It means that parcel will keep a track of all the files which
you are updating.
)
-- file watching algo (C++)
-- cashing -- faster builds(Super fast build algorithm)
--Bundling
--Minify Code (-- minification of files)
--Cleaning our code
-- image optimization 
--Compression of files
-- consistance hashing => 
-- code spliting 

-- defferenial bundling =>it create different bundels for different BR.( support older BR. as well)

-- Error handling => better error suggestion (Diagnostics)

--Https on dev mode 
--Port No
-- lazy dev builds
-- Tree shaking -- remove unused code for you 
-- different dev and production builds

parcel-cache:
Parcel caches code all the time.
When we run the application, a build is created which takes some time in ms.
If we make any code changes and save the application, another build will be triggered which might take even less time than the previous build.
This reduction of time is due to parcel cache.
thats how Parcel gives faster build.

dist:
It keeps the files minified for us.
When bundler builds the app, the build goes into a folder called dist.
The `/dist` folder contains the minimized and optimised version of the source code. and serves it on the server.

#Browserslist:
Browserslist is a tool that specifies which browsers should be supported/compatible in your frontend app.

It makes our code compatible for a lot of browsers.


#Tree Shaking:
Tree shaking is a process of  code optimization in which removing the unwanted code that we do not use while developing the application.

In computing, tree shaking is a dead code elimination
technique that is applied when optimizing code.



EP03-->

#npm scripts  --> 
 npm run start =>npx parcel index.html => its creates dev build

 npm run build =>npx parcel build index.html => its creates prod build

#Core of react => using React.createElement('element name',{},child)

#JSX => jsx is not html inside js. it is a syntex extention of js 
jsx is html or xml  like syntex
It is not a part of React. 
JavaScript engine cannot understand JSX as it only
understands ECMAScript.

 Is JSX a valid JavaScript? => JSX is not a valid Javascript syntax as it’s not pure HTML or
pure JavaScript for a browser to understand.

The JS engine does not understand JSX because
the JS engine understands ECMAScript 

 If the browser can’t understand JSX how is it still working? => 
This is because of Parcel because “Parcel is a Beast”.
Before the code gets to JS Engine it is sent to Parcel and
Transpiled there. Then after transpilation, the browser gets the code that it can understand.
Transpilation ⇒ Converting the code in such a format that the browsers can understand. 

Advantages of using JSX.
1) Sanitizes the data
If someone gets access to your JS code and sends some malicious
data which will then get displayed on the screen, that attack is called cross-site scripting.
It can read cookies, local storage, session storage, get cookies, get info about your device, and read data. JSx takes care of your data.
If some API passes some malicious data JSX will escape it. It prevents cross-site scripting and sanitizes the data before rendering


#babal => js compiler 
 => browser doesnt even know react exist. babal behand the scense it converts that browser understand. 

 JSX (transpiled by Babel) ⇒ React.createElement ⇒ ReactElement is JS Object ⇒usng .render() method HTML Element(render)

#components => classbased compo
            => functonal compo




EP-04 -->

#Introducing Props.

Short form for properties. To dynamically send data to a
component we use props. Passing a prop to a function is like
passing an argument to a function.

Props will be wrapped and send in Javascript object

Destructuring Props =>
const RestaurantCard = ({resName, cuisine}) => {
 return(
 <div>{resName}</div>
 )
}

#Good Practices
Destructuring props
Optional Chaining
Example,
const {name, avgRating, cuisine} = resData?.data;

#Config Driven UI.
It is a user Interface that is built and configured using a
declaration configuration file or data structure, rather than
being hardcoded.
Config is the data coming from the api which keeps on changing
according to different factors like user, location, etc. 


#Key
Unique Key id while using mapEach item in the list must be uniquely identified
Why?
When we have components at same level and if a new component
comes on the first without ID, DOM is going to re-render all the components again.
 As DOM can’t identify where to place it.
But if we give each of them a unique ID then react knows where
to put that component according to the ID. It is a good
optimization and performance thing.
Note* Never use index as keys in map. It is not recommended.


















